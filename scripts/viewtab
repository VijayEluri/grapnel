#!/usr/bin/env groovy 

/*
	TODO Add overall descriptive statistics (at least to the plots)
	TODO "Pin" plots so that you can select different rows and plot will update. 
	TODO Run functions on rows... for example BimodalityFilter, and get some kind of output. 
	TODO Move some of this code into a library so that it can get more complex. 
	TODO Add search facility (e.g. search row names for PTEN)
	TODO Set app name to be the name of the file so can switch to it easily
	TODO Set main menu name to be viewtab instead of Groovy 
	^^ These last two will probably require packaging viewtab up as an OS X app, with the
	   viewtab script buried inside resources or some such. 
	   Not sure what the implications are for other platforms. 
*/

import groovy.swing.SwingBuilder
import javax.swing.JTable
import javax.swing.*
import javax.swing.table.AbstractTableModel;
import java.awt.*;
import javax.swing.*;
import java.awt.event.*;

import org.jfree.chart.*
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.plot.*
import org.jfree.chart.renderer.xy.*;
import org.jfree.data.xy.*;
import org.jfree.ui.*
import org.jfree.data.statistics.*;

import com.google.common.primitives.Doubles;

import com.apple.eawt.Application;

import durbin.util.*
import static durbin.charts.Charts.*

import org.apache.commons.math3.stat.correlation.SpearmansCorrelation

err = System.err

// Enable system specific GUI features...
if (isOSX()){
	//err.println "IS OSX"
	System.setProperty("apple.laf.useScreenMenuBar", "true");
	System.setProperty("com.apple.mrj.application.apple.menu.about.name", "ViewTable");
	// set the look and feel
	UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
	
	// Set the dock icon. 
	def scriptDir = new File(getClass().protectionDomain.codeSource.location.path).parent
	def imgFileName = scriptDir+"/img/viewtab.png"
	def dockImage = new ImageIcon(imgFileName).getImage();
	Application.getApplication().setDockIconImage(dockImage);
	
	// Let's see what other methods Application has...
	//println Application.metaClass.methods*.name.sort().unique() 
}

options = ParseOptions(args)

// Determine separator to use...
if (options.separator) sep = options.separator
else sep = FileUtils.determineSeparator(options.fileName)

if (options.qregex){
	sep = /,(?=([^\"]|\"[^\"]*\")*$)/
}


// Read the data in as a Table...
dt = new Table(options.fileName,sep,bFirstColInTable=true)

// Use that Table to back a JTable instance..
err.print "Creating gui table..."
dtm = new TableModel(dt)

// Create a swingbuilder...
swing = new SwingBuilder()

// define some menus...
def menuItems = {
		menu(text: "Actions", mnemonic: 'F') {
			menuItem(text: "Exit", mnemonic: 'X', actionPerformed: { System.exit(0) })
		}
}

// Build the frame...
def thetab
frame = swing.frame(title:options.fileName,defaultCloseOperation:JFrame.EXIT_ON_CLOSE){
//	frame = swing.frame(title:options.fileName){
	menuBar(menuItems)
		
	// Add a scroll pane with table inside...
  scrollpane = scrollPane{						
		thetab = table(autoResizeMode:JTable.AUTO_RESIZE_OFF, 
										autoCreateRowSorter:true,
										cellSelectionEnabled:false,
										columnSelectionAllowed:true,
										preferredScrollableViewportSize:[900,400]){
			tableModel(dtm)										
		}							
  }
}
err.println "done."

// Set the default selection mode for the table...
thetab.columnSelectionAllowed = false
thetab.rowSelectionAllowed = true
bRowSelection = true

// Add popup menu to table for right-click on cells...
def popupMenuItems = {
	menuItem(text:"Select Rows",actionPerformed:{
		bRowSelection = true;
		thetab.columnSelectionAllowed = false
		thetab.rowSelectionAllowed = true})
	
	menuItem(text:"Select Columns",actionPerformed:{
		bRowSelection = false;
		thetab.columnSelectionAllowed = true
		thetab.rowSelectionAllowed = false})	

	separator()	
	menuItem(text:"Histogram of Selection",actionPerformed:{
		if (bRowSelection){
			selectedRows = thetab.getSelectedRows()
			histogramSelectedRows(thetab,selectedRows)
		}else{
			selectedCols = thetab.getSelectedColumns()
			histogramSelectedCols(thetab,selectedCols)
		}
	})
	
	menuItem(text:"Scatterplot Selection",actionPerformed:{
		if (bRowSelection){
			//err.println "scatterplot rows not yet implemented"
			selectedRows = thetab.getSelectedRows()
			scatterPlotSelectedRows(thetab,selectedRows)
		}else{
			selectedCols = thetab.getSelectedColumns()
			scatterPlotSelectedCols(thetab,selectedCols)
		}
	})
}


thetab.setComponentPopupMenu(swing.popupMenu(popupMenuItems))

// Show everything...
frame.pack()
frame.show()

def isOSX() {
	String osName = System.getProperty("os.name");
	return osName.contains("OS X");
}

def histogramSelectedRows(thetab,selectedRows){	
	selectedRows.each{rowIdx->	
		// Get the name of the row...
		def rowName = thetab.getValueAt(rowIdx,0)
		
		def cols = thetab.getColumnCount();
		def values = []
		for(int col = 0;col < cols;col++){
			try{
				o = thetab.getValueAt(rowIdx,col)
				v = o as double
				if (Double.isNaN(o)) return;
				values.add(v)
			}catch(Exception e){
				// Don't do anything...
				err.println "WARNING: row $rowName contains non-numeric values."
			}					
		}
		def hist = hist(rowName,values)
		showTableChart(hist,"Distribution of $rowName")	
	}
}

def histogramSelectedCols(thetab,selectedCols){			
	selectedCols.each{colIdx->
		// Get the name of the column...
		th = thetab.getTableHeader();  
		tcm = th.getColumnModel(); 
		tc = tcm.getColumn(colIdx)
		colName = tc.getHeaderValue()	
				
		rows = thetab.getRowCount();
		values = getRowValues(thetab,colIdx)
		
		if (values.size() == 0) return;		
		hist = hist(colName,values)
		showTableChart(hist,"Distribution of $colName")	
	}
}

def scatterPlotSelectedRows(thetab,selectedRows){			
	if(selectedRows.size() != 2){
		err.println "ERROR: Can only scatter plot exactly two rows."
		return;
	}
	
	row0 = selectedRows[0]
	rowName0 = getRowName(thetab,row0)
	
	row1 = selectedRows[1]
	rowName1 = getRowName(thetab,row1)
	
	err.println "plotting $rowName0 vs $rowName1"

	(values0,values1) = getMatchedColValues(thetab,row0,row1)
	def corr = new SpearmansCorrelation().correlation(values0 as double[],values1 as double[]);

	if (values0.size() != values1.size()){
		err.println "ERROR: rows do not contain same number of values."
	}
		
	scatter = xyplot("$rowName0 vs $rowName1 (Spearman=${corr.round(3)})",
					 rowName0,rowName1,values0,values1)
	showTableChart(scatter,"Scatterplot of $rowName0 vs $rowName1")	
}


def scatterPlotSelectedCols(thetab,selectedCols){			
	if(selectedCols.size() != 2){
		err.println "ERROR: Can only scatter plot exactly two columns."
		return;
	}
	
	col0 = selectedCols[0]
	colName0 = getColName(thetab,col0)
	
	col1 = selectedCols[1]
	colName1 = getColName(thetab,col1)
	
	err.println "plotting $colName0 vs $colName1"

	(values0,values1) = getMatchedRowValues(thetab,col0,col1)
	def corr = new SpearmansCorrelation().correlation(values0 as double[],values1 as double[]);

	if (values0.size() != values1.size()){
		err.println "ERROR: columns do not contain same number of values."
	}
		
	scatter = xyplot("$colName0 vs $colName1 (Spearman=${corr.round(3)})",
					 colName0,colName1,values0,values1)
	showTableChart(scatter,"Scatterplot of $colName0 vs $colName1")	
}


def getColName(thetab,colIdx){
	th = thetab.getTableHeader();  
	tcm = th.getColumnModel(); 
	tc = tcm.getColumn(colIdx)
	colName = tc.getHeaderValue()	
	return(colName)
}

def getRowName(thetab,rowIdx){
	def rowName = thetab.getValueAt(rowIdx,0)
	return(rowName)
}


/*
* Some cols may be missing values in one or other selected row.  
* Omit those values form the list. 
*/ 
def getMatchedColValues(thetab,rowIdx1,rowIdx2){
	def values = []		
	def cols = thetab.getColumnCount();	
	def colIdxs = []
	
	for(int col = 0;col < cols;col++){
		o = thetab.getValueAt(rowIdx1,col)
		try{
			v = o as double
			if (!Double.isNaN(v)) {				
				// Record that this col has a valid value. 
				colIdxs.add(col)
			}
			values.add(v) // just to pad out the list
		}catch(Exception e){				
		}			
	}		
	// For second row, only consult colss that had values
	// in the first row...
	def values1 = []
	def values2 = []
	colIdxs.each{col->
		o = thetab.getValueAt(rowIdx2,col)
		try{
			v = o as double
			if (!Double.isNaN(v)) {
				v2 = values[col]				
				if (v2 != null){
					// Since it occurs in both rows, add them to the outputs...
					values1.add(values[col])
					values2.add(v)
				}
			}
		}catch(Exception e){				
		}	
	}	
	return([values1,values2])
}

/*
* Some rows may be missing values in one or other column.  
* Omit those values form the list. 
*/ 
def getMatchedRowValues(thetab,colIdx1,colIdx2){
	def values = []		
	def rows = thetab.getRowCount();	
	def rowIdxs = []
	
	for(int row = 0;row < rows;row++){
		o = thetab.getValueAt(row,colIdx1)
		try{
			v = o as double
			if (!Double.isNaN(v)) {				
				// Record that this row has a valid value. 
				rowIdxs.add(row)
			}
			values.add(v) // just to pad out the list
		}catch(Exception e){				
		}			
	}		
	// For second column, only consult rows that had values
	// in the first column...
	def values1 = []
	def values2 = []
	rowIdxs.each{row->
		o = thetab.getValueAt(row,colIdx2)
		try{
			v = o as double
			if (!Double.isNaN(v)) {
				v2 = values[row]				
				if (v2 != null){
					// Since it occurs in both columns, add them to the outputs...
					values1.add(values[row])
					values2.add(v)
				}
			}
		}catch(Exception e){				
		}	
	}	
	System.err.println "values1: "+values1.size()
	System.err.println "values2: "+values2.size()
	return([values1,values2])
}


def getRowValues(thetab,colIdx){
	def values = []		
	def rows = thetab.getRowCount();
	for(int row = 0;row < rows;row++){
		o = thetab.getValueAt(row,colIdx)
		try{
			v = o as double
			if (!Double.isNaN(v)) values.add(v)
		}catch(Exception e){				
			// Don't do anything...
			err.println "WARNING: column ${getColName(thetab,colIdx)} contains non-numeric values."
		}			
	}
	return(values)
}

/****
* Show the chart in a new window.  
*/ 
static showTableChart(chart,chartTitle){
	def swing = new SwingBuilder()
	def frame = swing.frame(title:chartTitle,
													pack:true,show:true) {
		borderLayout()
		panel(new ChartPanel(chart),preferredSize: new java.awt.Dimension(500,300),mouseWheelEnabled:true)
	}
	return(swing)		
}



def printSelectedCols(thetab,selectedCols){
	model = thetab.getSelectionModel();
	colIdx = selectedCols[0] // OK, just print the first col...
	rows = thetab.getRowCount();
	for(int row = 0;row < rows;row++){
		o = thetab.getValueAt(row,colIdx)
		println o
	}
	println "\n\n"
}



/****************************************************
* Parse the command line options, checking validity, printing help if needed. 
*/ 
def ParseOptions(args){
	parser = new Parser(description: '''	
	Produces a spreedsheet-like display of a table of data (csv, tab).  Works like a regular
	spreadsheet, columns can be sorted, rearranged, etc.  Allows the display of tables of data much too 
	large for normal spreadsheets, though. Auto-detects tab or csv files.  Can overtly specify
	separator in case of other separator or mixed tab/, headings.   
	
	Control-click on table for a pop-up to toggle between selecting columns and selecting rows.  Pop-up
	also includes option to plot a histogram of the values in selected rows/columns.  Multiple columns
	can be selected to produce a scatter plot. 
	
	Written by: James Durbin (kdurbin@ucsc.edu)
	
	Use like:
	
	viewtab data.tab
	
	viewtab -s "\\t" data.tab

	''');

	try{ 
		parser.with{
			optional 's','separator',[description: 'Force separator to be this character.']
			flag 'q','qregex',[default:false,description: 'Use a regex to capture quoted comma lists as single field (slower).']
	  		flag 'h','help',[default:false,description: 'Print script help.']
			remainder{			
				if(!it) throw new Exception("Must specify a file.");
				it
			}
		}
	
		options = parser.parse(args); 
		options.fileName = parser.remainder[0]
	}catch(Exception e){
		System.err << parser.usage;
		System.exit(1)
	}		
	return(options)
}

//*************************************
// Supporting classes
//*************************************
class TableModel extends AbstractTableModel{		
	Table dt;
	
	// As the user selects columns, determine if the 
	// column is numeric or not and cache this fact 
	// for sorting and such.  
	def column2TypeCache = [:]
	
	TableModel(Table table){dt = table;}

	public String getColumnName(int col) {return(dt.colNames[col]);}	
	public String getRowName(int row){
		def rowName = dt.rowNames[row]
		println "getRowName: $row \t $rowName"
		return(rowName);
	}	
	public int getRowCount() { return(dt.rows())}
	public int getColumnCount() { return(dt.cols())}
	
	// Maybe implement this in Table as a special 
	// getTypedAt() sort of method... 	
	// Do type conversion here instead of loading because 
	// don't want to pay to convert everything, just what see/use. 
	public Object getValueAt(int row, int col) {		
		if (col==0) return(dt.get(row,col))							
		if (column2TypeCache.containsKey(col)){
			if(column2TypeCache[col] == Double.class){
				try{
				return(Double.parseDouble(dt.get(row,col)))
				}catch(Exception e){
					return(Double.NaN)
				}
			}else{
				return(dt.get(row,col))	
			}
		}else{
			column2TypeCache[col] = determineColumnType(col)
			if(column2TypeCache[col] == Double.class){
				try{
					return(Double.parseDouble(dt.get(row,col)))
				}catch(Exception e){
					return(Double.NaN)
				}
			}else{
				return(dt.get(row,col))
			}
		}
	}
	
	public Class getColumnClass(int c) {
		if (c == 0) return(String.class)
		
		if (column2TypeCache.containsKey(c)){
			return(column2TypeCache[c])
		}else{
			column2TypeCache[c] = determineColumnType(c)
			return(column2TypeCache[c])
		}
	}  	
	public boolean isCellEditable(int row, int col){return false;}	
	public void setValueAt(Object value, int row, int col) {}
	
	
	// To make it more efficient only look at the first 100 rows
	// If they are all numbers, assume the whole column is numbers. 
	def determineColumnType(c){
		def rows = dt.numRows 
		int scanEnd = (500 < rows) ? 500 : (rows -1)
				
		int numcount = 0;
		for(int i = 0;i < scanEnd;i++){
			 if (Doubles.tryParse(dt.get(i,c)) != null) numcount++
		}
		def acceptCount = scanEnd* 0.5
		if (numcount >= acceptCount) {
			//System.err.println "col: ${getColumnName(c)} is Double"
			return(Double.class)
		}
		else {
			//System.err.println "col: ${getColumnName(c)} is String"
			return(String.class)		
		}
	} 
		
}



/**

17206x1037 (17,842,622) 
326MB file (many digits per souble)
24s

26895 x 466 (12,533,070)
10-15 seconds. 

20530 x 823 (16,896,190)
viewtab:
19s
14s
20s

vt:
14s
18s
19s
18s

Numbers:
143s

*/